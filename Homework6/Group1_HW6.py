# -*- coding: utf-8 -*-
"""pythonCode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/nurfnick/Metaheuristics/blob/main/Homework6/pythonCode.ipynb

# Meta-Heuristics Homework 6
"""

import copy
from random import Random   #need this for the random number generation -- do not change
import numpy as np

#to setup a random number generator, we will specify a "seed" value
#need this for the random number generation -- do not change
seed = 51132023
myPRNG = Random(seed)

#to get a random number between 0 and 1, use this:             myPRNG.random()
#to get a random number between lwrBnd and upprBnd, use this:  myPRNG.uniform(lwrBnd,upprBnd)
#to get a random integer between lwrBnd and upprBnd, use this: myPRNG.randint(lwrBnd,upprBnd)

#number of elements in a solution
n = 150

#create an "instance" for the knapsack problem
value = []
for i in range(0,n):
    value.append(round(myPRNG.triangular(5,1000,200),1))

weights = []
for i in range(0,n):
    weights.append(round(myPRNG.triangular(10,200,60),1))

#define max weight for the knapsack
maxWeight = 2500

solutionsChecked = 0

#function to evaluate a solution x
def evaluate(x):

    a=np.array(x)
    b=np.array(value)
    c=np.array(weights)

    totalValue = np.dot(a,b)     #compute the value of the knapsack selection
    totalWeight = np.dot(a,c)    #compute the weight value of the knapsack selection

    if totalWeight > maxWeight:
         #print ("Oh no! The solution is infeasible!  What to do?  What to do?")   #you will probably want to change this...
         totalValue = -totalValue

    return [totalValue, totalWeight]   #returns a list of both total value and total weight


#here is a simple function to create a neighborhood
#1-flip neighborhood of solution x
def neighborhood(x):

    nbrhood = []

    for i in range(0,n):
        nbrhood.append(x[:])
        if nbrhood[i][i] == 1:
            nbrhood[i][i] = 0
        else:
            nbrhood[i][i] = 1

    return nbrhood
#take all the 1's and 0's and slide them around, keeping the order.
def neighborhood_slide(x):

    nbrhood = []

    for i in range(0,len(x)):
        newlist = x[i+1:]
        newlist.extend(x[:i+1])
        nbrhood.append(newlist)
    return nbrhood


def neighborhood_slide_and_flip(x):
  nbrhood = []

  for i in neighborhood(x):
    nbrhood.extend(neighborhood_slide(i))

  return nbrhood


#create the initial solution
def initial_solution_zero():
    x = []   #i recommend creating the solution as a list

    for i in range(n):
        x.append(0)

    return x

def initial_solution_random():
  x = []

  for i in range(n):
    x.append(myPRNG.randint(0,1))

  return x

def initial_solution_random_start_feasible():
  x = []

  for i in range(n):
    x.append(myPRNG.randint(0,1))

  i = myPRNG.randint(0,n-1)
  while evaluate(x)[1] > maxWeight:
    x[i] = 0
    i=myPRNG.randint(0,n-1)

  return x
#varaible to record the number of solutions evaluated
solutionsChecked = 0

x_curr = initial_solution_zero()  #x_curr will hold the current solution
x_best = x_curr[:]           #x_best will hold the best solution
f_curr = evaluate(x_curr)    #f_curr will hold the evaluation of the current soluton
f_best = f_curr[:]

"""## Best Improvement"""

#begin local search overall logic ----------------
x_curr = initial_solution_zero()  #x_curr will hold the current solution
x_best = x_curr[:]           #x_best will hold the best solution
f_curr = evaluate(x_curr)    #f_curr will hold the evaluation of the current soluton
f_best = f_curr[:]



solutionsChecked = 0

done = 0

while done == 0:

    Neighborhood = neighborhood_slide_and_flip(x_curr)   #create a list of all neighbors in the neighborhood of x_curr

    for s in Neighborhood:                #evaluate every member in the neighborhood of x_curr
        solutionsChecked = solutionsChecked + 1
        if evaluate(s)[0] > f_best[0]:
            x_best = s[:]                 #find the best member and keep track of that solution
            f_best = evaluate(s)[:]       #and store its evaluation

    if f_best == f_curr:                  #if there were no improving solutions in the neighborhood
        done = 1
    else:

        x_curr = x_best[:]         #else: move to the neighbor solution and continue
        f_curr = f_best[:]         #evalute the current solution

        print ("\nTotal number of solutions checked: ", solutionsChecked)
        print ("Best value found so far: ", f_best)

print ("\nFinal number of solutions checked: ", solutionsChecked)
print ("Best value found: ", f_best[0])
print ("Weight is: ", f_best[1])
print ("Total number of items selected: ", np.sum(x_best))
print ("Best solution: ", x_best)

"""## First Improvement"""

#begin local search overall logic ----------------
x_curr = initial_solution_zero()  #x_curr will hold the current solution
x_best = x_curr[:]           #x_best will hold the best solution
f_curr = evaluate(x_curr)    #f_curr will hold the evaluation of the current soluton
f_best = f_curr[:]



solutionsChecked = 0

done = 0

while done == 0:

    Neighborhood = neighborhood_slide_and_flip(x_curr)   #create a list of all neighbors in the neighborhood of x_curr

    for s in Neighborhood:                #evaluate every member in the neighborhood of x_curr
        solutionsChecked = solutionsChecked + 1
        if evaluate(s)[0] > f_best[0]:
            x_best = s[:]                 #find the best member and keep track of that solution
            f_best = evaluate(s)[:]       #and store its evaluation
            break

    if f_best == f_curr:                  #if there were no improving solutions in the neighborhood
        done = 1
    else:

        x_curr = x_best[:]         #else: move to the neighbor solution and continue
        f_curr = f_best[:]         #evalute the current solution

        print ("\nTotal number of solutions checked: ", solutionsChecked)
        print ("Best value found so far: ", f_best)

print ("\nFinal number of solutions checked: ", solutionsChecked)
print ("Best value found: ", f_best[0])
print ("Weight is: ", f_best[1])
print ("Total number of items selected: ", np.sum(x_best))
print ("Best solution: ", x_best)

"""## Random Restarts"""

k = 50
solns = []

for i in range(k):


  x_curr = initial_solution_random_start_feasible()  #x_curr will hold the current solution
  x_best = x_curr[:]           #x_best will hold the best solution
  f_curr = evaluate(x_curr)    #f_curr will hold the evaluation of the current soluton
  f_best = f_curr[:]

#begin local search overall logic ----------------
  done = 0
  solutionsChecked = 0

  while done == 0:

    Neighborhood = neighborhood_slide_and_flip(x_curr)   #create a list of all neighbors in the neighborhood of x_curr

    for s in Neighborhood:                #evaluate every member in the neighborhood of x_curr
        solutionsChecked = solutionsChecked + 1
        if evaluate(s)[0] > f_best[0]:
            x_best = s[:]                 #find the best member and keep track of that solution
            f_best = evaluate(s)[:]       #and store its evaluation
            break

    if f_best == f_curr:                  #if there were no improving solutions in the neighborhood
        done = 1
    else:

        x_curr = x_best[:]         #else: move to the neighbor solution and continue
        f_curr = f_best[:]         #evalute the current solution


  solns.append(solutionsChecked)
  solns.append(f_best[0])
  solns.append(f_best[1])
  solns.append(np.sum(x_best))
  solns.append(x_best)

weightsMax = []

for i in range(0,k*5,5): #five things added to the solution array each execution
  weightsMax.append(solns[i+1]) #objective is in 1 slot

iter = weightsMax.index(max(weightsMax)) #find iteration with best value

print ("\nFinal number of solutions checked: ", solns[5*iter]) #print results
print ("Best value found: ", solns[5*iter+1])
print ("Weight is: ", solns[5*iter+2])
print ("Total number of items selected: ", solns[5*iter+3])
print ("Best solution: ", solns[5*iter+4])

"""## Random Walk"""

#begin local search overall logic ----------------
x_curr = initial_solution_zero()  #x_curr will hold the current solution
x_best = x_curr[:]           #x_best will hold the best solution
f_curr = evaluate(x_curr)    #f_curr will hold the evaluation of the current soluton
f_best = f_curr[:]

p = .89

solutionsChecked = 0

done = 0

while done == 0:

    Neighborhood = neighborhood_slide_and_flip(x_curr)   #create a list of all neighbors in the neighborhood of x_curr
    ptest = myPRNG.random()

    if p>ptest:
      for s in Neighborhood:                #evaluate every member in the neighborhood of x_curr
        solutionsChecked = solutionsChecked + 1
        if evaluate(s)[0] > f_best[0]:
            x_best = s[:]                 #find the best member and keep track of that solution
            f_best = evaluate(s)[:]       #and store its evaluation
    else:
      randNbr = myPRNG.randint(0,len(Neighborhood)-1)
      x_best = Neighborhood[randNbr][:]
      f_best = evaluate(x_best)[:]

    if f_best == f_curr:                  #if there were no improving solutions in the neighborhood
        done = 1
    else:

        x_curr = x_best[:]         #else: move to the neighbor solution and continue
        f_curr = f_best[:]         #evalute the current solution

        print ("\nTotal number of solutions checked: ", solutionsChecked)
        print ("Best value found so far: ", f_best)
        print ("Current ptest value: ", ptest)

print ("\nFinal number of solutions checked: ", solutionsChecked)
print ("Best value found: ", f_best[0])
print ("Weight is: ", f_best[1])
print ("Total number of items selected: ", np.sum(x_best))
print ("Best solution: ", x_best)

"""## Stochastic Hill Climb"""

#begin local search overall logic ----------------
x_curr = initial_solution_zero()  #x_curr will hold the current solution
x_best = x_curr[:]           #x_best will hold the best solution
f_curr = evaluate(x_curr)    #f_curr will hold the evaluation of the current soluton
f_best = f_curr[:]



solutionsChecked = 0

done = 0

while done == 0:

    Neighborhood = neighborhood_slide_and_flip(x_curr)   #create a list of all neighbors in the neighborhood of x_curr
    improvements = []

    for s in Neighborhood:                #evaluate every member in the neighborhood of x_curr
        solutionsChecked = solutionsChecked + 1
        if evaluate(s)[0] > f_curr[0]:#compare to current not best
            improvements.append(s[:])                 #add to list
            improvements.append(evaluate(s)[:])       #and store its evaluation

    if len(improvements)>0:
        whichone = myPRNG.randint(0,len(improvements)/2 - 1) #randomly choose one of the improvements
        x_best = improvements[2*whichone]
        f_best = improvements[2*whichone +1]

    if f_best == f_curr:                  #if there were no improving solutions in the neighborhood
        done = 1
    else:

        x_curr = x_best[:]         #else: move to the neighbor solution and continue
        f_curr = f_best[:]         #evalute the current solution

        print ("\nTotal number of solutions checked: ", solutionsChecked)
        print ("Best value found so far: ", f_best)

print ("\nFinal number of solutions checked: ", solutionsChecked)
print ("Best value found: ", f_best[0])
print ("Weight is: ", f_best[1])
print ("Total number of items selected: ", np.sum(x_best))
print ("Best solution: ", x_best)

#begin local search overall logic ----------------
x_curr = initial_solution_zero()  #x_curr will hold the current solution
x_best = x_curr[:]           #x_best will hold the best solution
f_curr = evaluate(x_curr)    #f_curr will hold the evaluation of the current soluton
f_best = f_curr[:]



solutionsChecked = 0

done = 0

while done == 0:

    Neighborhood = neighborhood_slide_and_flip(x_curr)   #create a list of all neighbors in the neighborhood of x_curr
    improvements = []

    for s in Neighborhood:                #evaluate every member in the neighborhood of x_curr
        solutionsChecked = solutionsChecked + 1
        if evaluate(s)[0] > f_curr[0]:#compare to current not best
            improvements.append(s[:])                 #add to list
            improvements.append(evaluate(s)[:])       #and store its evaluation

    if len(improvements)>0:
      w = [] #array for values of improvments
      for i in range(int(len(improvements)/2)):
        w.append(improvements[2*i +1][0]) #just want the values


      whichone = myPRNG.choices(range(int(len(improvements)/2)), weights = w, k = 1)[0] #randomly choose one of the improvements based on weights of those improvements
      x_best = improvements[2*whichone]
      f_best = improvements[2*whichone +1]

    if f_best == f_curr:                  #if there were no improving solutions in the neighborhood
        done = 1
    else:

        x_curr = x_best[:]         #else: move to the neighbor solution and continue
        f_curr = f_best[:]         #evalute the current solution

        print ("\nTotal number of solutions checked: ", solutionsChecked)
        print ("Best value found so far: ", f_best)

print ("\nFinal number of solutions checked: ", solutionsChecked)
print ("Best value found: ", f_best[0])
print ("Weight is: ", f_best[1])
print ("Total number of items selected: ", np.sum(x_best))
print ("Best solution: ", x_best)

